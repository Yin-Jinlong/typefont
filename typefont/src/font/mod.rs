use bit_struct::u24;

pub mod io;
pub mod open_type;
pub mod table;
pub mod table_record;
pub mod true_type;
pub mod ttc;

// 在本规范中，许多结构是根据上述数据类型定义的。结构被划分为记录或表。记录与表之间的区别基于以下标准：
//
// - 表通过偏移量引用。如果一个表包含对子结构的偏移量，该偏移量通常是从该表的开始处计算的。
// - 记录在一个父结构内顺序出现，无论是位于表字段序列中还是作为给定类型的记录数组的一部分。
// 如果一个记录包含对子结构的偏移量，那么该结构在逻辑上是记录的父表的子表，
// 且偏移量通常是从父表的开始处计算的。
//
// 在某些情况下，对于可选子表的偏移量字段，允许其值为 `NULL`。
// 例如，在 `BASE` 表头中，`horiz_axis_offset` 和 `vert_axis_offset` 字段可以为 `NULL`，
// 这意味着对应的子表（或两者）是可选的。一个 `NULL` 子表偏移量总是表示对应的子表不存在。
// 应用程序绝不能将 `NULL` 偏移量值解释为指向子表数据的偏移量。
// 对于那些没有文档说明允许 `NULL` 值的子表偏移量字段，字体编译器必须包括一个指定格式的子表，
// 即使它只是一个没有进一步数据的头部存根（例如，没有任何字形 ID 的覆盖表）。
// 然而，解析字体数据的应用程序应该预料到存在不符合规范的字体数据，
// 其中预期非 `NULL` 值的地方可能出现 `NULL` 子表偏移量。

type Fixed = i32;

/// int16 来描述以字体设计单位表示的数量。
type FWord = i16;

/// uint16 来描述以字体设计单位表示的数量。
type UFWord = u16;

/// 日期和时间，以自 1904 年 1 月 1 日午夜 12：00 （UTC）
/// 以来的秒数表示。该值表示为有符号的 64 位整数。
type LongDataTime = i64;

/// 标签值是一个 `uint8` 数组。
/// 数组中的每个字节都必须具有 `0x20` 到 `0x7E` 之间的值。
/// 这对应于 `UTF-8` 编码中 `Unicode` 基本拉丁字符的值范围，也就是可打印的 `ASCII` 字符。
/// 因此，标签值可以重新解释为一个四字符序列，通常这是它们的引用方式。
/// 然而，从形式上讲，该值是一个字节数组。当重新解释为字符时，标签值区分大小写。
/// 它必须包含一到四个非空格字符，并以尾随空格（字节值 `0x20`）填充。
/// 不允许空格字符后跟随非空格字符。
type Tag = [u8; 4];

type Offset8 = u8;
type Offset16 = u16;
type Offset24 = u24;
type Offset32 = u32;

// u16.u16
type Version16Dot16 = u32;
